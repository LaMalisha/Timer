<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timer Fluido Cosmico</title>
    <!-- Caricamento di Tailwind CSS per uno stile moderno e responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Impostazioni di configurazione e font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        /* 1. Animazione del Bagliore Pulsante */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.4), 0 0 5px rgba(0, 255, 255, 0.7); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.7), 0 0 15px rgba(0, 255, 255, 1); }
            100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.4), 0 0 5px rgba(0, 255, 255, 0.7); }
        }

        /* 2. Animazione della Sfocatura (per Focus Working) */
        @keyframes subtle-blur {
            0%, 100% { filter: blur(0px); opacity: 1; }
            50% { filter: blur(0.5px); opacity: 0.95; }
        }

        .timer-text {
            font-size: 3.5rem; /* Large text for time */
            letter-spacing: 2px;
            font-weight: 700;
            color: #e2e8f0; /* Light text for dark background */
            /* NUOVA INTEGRAZIONE VISIVA: Il testo non ha sfondo solido */
            background-color: transparent; 
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            /* Aggiunge un leggero glow interno al testo */
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.6);
        }
        
        .timer-running {
            animation: pulse-glow 2s infinite alternate ease-in-out;
        }

        /* Stile per il conteggio circolare dei secondi (simulazione) */
        .countdown-circle {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .countdown-circle-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            /* Bordo più sottile e integrato */
            border: 6px solid #1f2937; /* Darker gray border */ 
        }
        
        /* 3. Stile base del riempimento (colore Ciano) */
        .countdown-circle-fill {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 6px solid transparent;
            /* La linea di riempimento è la *parte inferiore* per partire dall'alto */
            border-top-color: #00ffff; 
            transition: transform 0.1s linear, border-top-color 0.5s;
            transform: rotate(270deg); /* INIZIO DALL'ALTO (posizione 12) */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            
            /* Questo è il trucco per l'effetto "riempimento che scende":
               La rotazione parte da -90 gradi (alto) e va in senso orario (aumento) */
        }

        /* Modificatori CSS basati sulla categoria (aggiunti da JS) */
        .focus-style .countdown-circle-fill {
            border-top-color: #00ffff; /* Cyan */
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8), 0 0 3px rgba(0, 255, 255, 0.4) inset;
            animation: subtle-blur 4s infinite ease-in-out;
        }
        .workout-style .countdown-circle-fill {
            border-top-color: #34d399; /* Emerald Green */
            box-shadow: 0 0 15px rgba(52, 211, 153, 0.8), 0 0 3px rgba(52, 211, 153, 0.4) inset;
        }

        /* Responsive Layout for Preset Sections */
        @media (min-width: 1024px) {
            .presets-container {
                display: flex;
                flex-direction: column;
                gap: 1.5rem; /* gap-6 */
            }
        }

    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 sm:p-8 flex flex-col items-center">

    <h1 class="text-4xl font-bold mb-10 text-cyan-400">Timer Fluido Cosmico</h1>

    <main class="w-full max-w-6xl flex flex-col lg:flex-row gap-8">
        
        <!-- SEZIONE TIMER PRINCIPALE -->
        <section class="lg:w-1/2 bg-gray-800 p-6 rounded-2xl shadow-2xl border border-gray-700">
            <h2 class="text-2xl font-semibold mb-6 text-center text-cyan-300">Il Tuo Timer</h2>

            <!-- Display del Timer con Cerchio -->
            <div class="flex justify-center mb-8">
                <div id="countdownCircle" class="countdown-circle">
                    <div class="countdown-circle-bg"></div>
                    <!-- Il container del cerchio riceve la classe per lo stile dinamico -->
                    <div id="countdownFill" class="countdown-circle-fill"></div>
                    <!-- Il testo è ora integrato senza sfondo solido -->
                    <div id="timerDisplay" class="timer-text">00:00:00</div>
                </div>
            </div>

            <!-- Input per Impostare il Tempo -->
            <div class="flex justify-center space-x-4 mb-8">
                <div class="flex flex-col items-center">
                    <label for="hours" class="text-sm text-gray-400">Ore (H)</label>
                    <input type="number" id="hours" min="0" max="99" value="0" class="w-16 p-2 bg-gray-700 border border-gray-600 rounded-lg text-center text-xl focus:border-cyan-400 focus:ring-1 focus:ring-cyan-400 transition">
                </div>
                <div class="flex flex-col items-center">
                    <label for="minutes" class="text-sm text-gray-400">Minuti (M)</label>
                    <input type="number" id="minutes" min="0" max="59" value="0" class="w-16 p-2 bg-gray-700 border border-gray-600 rounded-lg text-center text-xl focus:border-cyan-400 focus:ring-1 focus:ring-cyan-400 transition">
                </div>
                <div class="flex flex-col items-center">
                    <label for="seconds" class="text-sm text-gray-400">Secondi (S)</label>
                    <input type="number" id="seconds" min="0" max="59" value="0" class="w-16 p-2 bg-gray-700 border border-gray-600 rounded-lg text-center text-xl focus:border-cyan-400 focus:ring-1 focus:ring-cyan-400 transition">
                </div>
            </div>

            <!-- Controlli Timer -->
            <div class="flex justify-center space-x-4 mb-6">
                <button id="startButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition shadow-lg shadow-green-900/50 flex items-center disabled:opacity-50">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.168V8.832a1 1 0 011.555-.832l3.197 2.132c.243.161.243.515 0 .676z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Avvia
                </button>
                <button id="pauseButton" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-xl transition shadow-lg shadow-yellow-900/50 flex items-center disabled:opacity-50" disabled>
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Pausa
                </button>
                <button id="resetButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-xl transition shadow-lg shadow-red-900/50 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.958 8.958 0 0120 12a9 9 0 01-9 9m-4.502-14.075a.999.999 0 01-.252-.45c-.173-.55-.615-.71-1.165-.436-.549.273-.72.715-.546 1.265A10 10 0 0021.2 12c.708 0 1.284.576 1.284 1.284v.041c0 .708-.576 1.284-1.284 1.284-3.52 0-6.72-.258-9.6-.745a.999.999 0 01-.735-1.29 1 1 0 011.3-.735c2.474.4 4.885.545 7.185.545.24 0 .445.195.45.435.005.239-.19.44-.43.44zm-14-1.921A9.002 9.002 0 013 12a9 9 0 019-9c.708 0 1.284.576 1.284 1.284v.041c0 .708-.576 1.284-1.284 1.284-3.52 0-6.72-.258-9.6-.745a.999.999 0 01-.735-1.29 1 1 0 011.3-.735c2.474.4 4.885.545 7.185.545.24 0 .445.195.45.435.005.239-.19.44-.43.44z"></path></svg>
                    Reset
                </button>
            </div>

        </section>

        <!-- SEZIONE PRESET DIVISA IN DUE COLONNE -->
        <section class="lg:w-1/2 presets-container">

            <!-- COLONNA 1: FOCUS WORKING -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-2xl border border-gray-700">
                <h2 class="text-2xl font-semibold mb-6 text-center text-cyan-300">Focus Working (Pomodoro)</h2>
                <div id="presetsList" class="space-y-3">
                    <!-- 1. Timer Pomodoro da 20 minuti -->
                    <button data-h="0" data-m="20" data-s="0" data-category="Focus Working" data-name="Timer Pomodoro" class="preset-button w-full flex items-center justify-between bg-gray-700 p-3 rounded-xl hover:bg-gray-600 transition shadow-md hover:shadow-cyan-500/30">
                        <span class="font-medium text-cyan-200">Timer Pomodoro</span>
                        <span class="text-sm text-gray-400">00:20:00</span>
                    </button>
                    <!-- 2. Timer Pausa Breve da 5 minuti -->
                    <button data-h="0" data-m="5" data-s="0" data-category="Focus Working" data-name="Pausa Breve" class="preset-button w-full flex items-center justify-between bg-gray-700 p-3 rounded-xl hover:bg-gray-600 transition shadow-md hover:shadow-cyan-500/30">
                        <span class="font-medium text-cyan-200">Pausa Breve</span>
                        <span class="text-sm text-gray-400">00:05:00</span>
                    </button>
                    <!-- 3. Timer Pausa Lunga da 15 minuti -->
                    <button data-h="0" data-m="15" data-s="0" data-category="Focus Working" data-name="Pausa Lunga" class="preset-button w-full flex items-center justify-between bg-gray-700 p-3 rounded-xl hover:bg-gray-600 transition shadow-md hover:shadow-cyan-500/30">
                        <span class="font-medium text-cyan-200">Pausa Lunga</span>
                        <span class="text-sm text-gray-400">00:15:00</span>
                    </button>
                </div>
            </div>
            
            <!-- COLONNA 2: WORKOUT -->
            <div class="bg-gray-800 p-6 rounded-2xl shadow-2xl border border-gray-700">
                <h2 class="text-2xl font-semibold mb-6 text-center text-green-300">WorkOut (Interval Training)</h2>
                <div id="workoutPresetsList" class="space-y-3">
                    <!-- 1. Pausa Breve (30 secondi) -->
                    <button data-h="0" data-m="0" data-s="30" data-category="WorkOut" data-name="Recupero Rapido" class="preset-button w-full flex items-center justify-between bg-gray-700 p-3 rounded-xl hover:bg-gray-600 transition shadow-md hover:shadow-green-500/30">
                        <span class="font-medium text-green-200">Recupero Rapido</span>
                        <span class="text-sm text-gray-400">00:00:30</span>
                    </button>
                    <!-- 2. Pausa Lunga (1 minuto) -->
                    <button data-h="0" data-m="1" data-s="0" data-category="WorkOut" data-name="Recupero Attivo" class="preset-button w-full flex items-center justify-between bg-gray-700 p-3 rounded-xl hover:bg-gray-600 transition shadow-md hover:shadow-green-500/30">
                        <span class="font-medium text-green-200">Recupero Attivo</span>
                        <span class="text-sm text-gray-400">00:01:00</span>
                    </button>
                </div>
            </div>

        </section>

    </main>

    <!-- Modale per Messaggi (es. Timer scaduto) -->
    <div id="messageModal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl border border-cyan-400 w-96 text-center">
            <h3 id="modalTitle" class="text-3xl font-bold text-cyan-400 mb-4">Timer Scaduto!</h3>
            <p id="modalMessage" class="text-lg text-gray-200 mb-6">Il tempo è finito. Ben fatto!</p>
            <button id="closeModalButton" class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-6 rounded-xl transition shadow-md">Chiudi</button>
        </div>
    </div>

    <!-- Sezione JavaScript -->
    <script type="module">
        // Variabili Globali
        let countdownInterval;
        let totalSecondsRemaining = 0;
        let timerRunning = false;
        let totalSecondsInitial = 0; // Per calcolare la percentuale del cerchio
        let lastPresetCategory = 'Focus Working'; // Categoria per la logica Gemini
        let fetchedTip = { text: null, sources: [] }; // Per memorizzare il consiglio Gemini
        
        // Elementi DOM
        const timerDisplay = document.getElementById('timerDisplay');
        const countdownFill = document.getElementById('countdownFill');
        const countdownCircle = document.getElementById('countdownCircle'); // Riferimento al div contenitore
        const hoursInput = document.getElementById('hours');
        const minutesInput = document.getElementById('minutes');
        const secondsInput = document.getElementById('seconds');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const resetButton = document.getElementById('resetButton');
        
        // Liste dei Preset
        const focusPresetsList = document.getElementById('presetsList');
        const workoutPresetsList = document.getElementById('workoutPresetsList');

        const messageModal = document.getElementById('messageModal');
        const closeModalButton = document.getElementById('closeModalButton');

        // Aggiungi contesto audio globale per la riproduzione del suono
        let audioContext;

        /** Funzione per applicare lo stile CSS dinamico in base alla categoria */
        const applyDynamicStyles = (category) => {
            // Rimuove tutte le classi di stile dinamiche esistenti
            countdownCircle.classList.remove('focus-style', 'workout-style');
            timerDisplay.classList.remove('timer-running');
            
            if (category === 'Focus Working') {
                countdownCircle.classList.add('focus-style');
            } else if (category === 'WorkOut') {
                countdownCircle.classList.add('workout-style');
            }
            
            // Aggiunge l'animazione di pulsazione solo quando il timer è avviato
            if (timerRunning) {
                timerDisplay.classList.add('timer-running');
            }
        };


        // --- FUNZIONI UI E UTILITY ---

        /** Carica i valori del preset negli input */
        const loadPreset = (preset, category) => {
            // Se il timer è in corso, lo mettiamo in pausa prima di caricare il nuovo tempo
            pauseTimer(); 
            
            hoursInput.value = preset.hours;
            minutesInput.value = preset.minutes;
            secondsInput.value = preset.seconds;
            
            // Imposta il timer con i nuovi valori
            const h = parseInt(hoursInput.value) || 0;
            const m = parseInt(minutesInput.value) || 0;
            const s = parseInt(secondsInput.value) || 0;
            totalSecondsRemaining = h * 3600 + m * 60 + s;
            totalSecondsInitial = totalSecondsRemaining;
            
            lastPresetCategory = category; // Imposta la categoria usata per il timer
            fetchedTip = { text: null, sources: [] }; // Resetta il consiglio

            updateDisplay(); 
            updateButtonState(false);
            
            // Applica immediatamente gli stili del preset
            applyDynamicStyles(category);

            showModal("Preset Caricato", `Caricato il timer: **${preset.name}**.`);
        };
        
        /** Funzione per riprodurre un suono di "Campana Tibetana" (5 secondi) */
        const playGong = () => {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Attiva l'AudioContext su interazione utente se è in stato "sospeso"
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const duration = 5.0; // 5 secondi
                const now = audioContext.currentTime;

                // 1. Primary deep sine tone (Fundamental - Basso e lungo)
                const osc1 = audioContext.createOscillator();
                const gain1 = audioContext.createGain();
                osc1.connect(gain1);
                gain1.connect(audioContext.destination);

                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(130.81, now); // Frequenza bassa (C3)
                gain1.gain.setValueAtTime(0.5, now);
                // Decadimento lento per effetto "gong lungo"
                gain1.gain.exponentialRampToValueAtTime(0.0001, now + duration);

                // 2. Higher tone for richness (Armonica) - Leggermente più alta
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                osc2.connect(gain2);
                gain2.connect(audioContext.destination);

                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(261.63, now); // Frequenza (C4)
                gain2.gain.setValueAtTime(0.3, now);
                // Decadimento leggermente più veloce
                gain2.gain.exponentialRampToValueAtTime(0.0001, now + duration * 0.8); 

                // Inizia e ferma gli oscillatori
                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + duration);
                osc2.stop(now + duration);
                
            } catch (e) {
                console.error("Errore nella riproduzione dell'audio:", e);
            }
        };
        
        /** Funzione per ottenere un consiglio da Gemini (con exponential backoff) */
        const fetchGeminiTip = async (category) => {
            // La modale è già aperta in stato di attesa
            fetchedTip = { text: null, sources: [] }; // Resetta il consiglio
            
            let systemPrompt;
            let userQuery;

            if (category === 'WorkOut') {
                systemPrompt = "Agisci come un coach di fitness. Fornisci un consiglio rapido, semplice (sotto le 30 parole) per il recupero, lo stretching o l'idratazione dopo una breve pausa di allenamento. Non usare titoli.";
                userQuery = "Fornisci un consiglio veloce per la pausa di allenamento (30 secondi o 1 minuto) incentrato su idratazione, stretching o respirazione. Usa un tono energico e motivante. Rispondi in italiano.";
            } else if (category === 'Focus Working') {
                // Logica per Crescita Personale / Focus
                systemPrompt = "Agisci come un coach di crescita personale. Fornisci un consiglio rapido, semplice (sotto le 30 parole) per migliorare la concentrazione, la consapevolezza o l'apprendimento personale. Rispondi in italiano. Non usare titoli.";
                userQuery = "Fornisci un consiglio motivante e veloce per una pausa dal lavoro (5-20 minuti), concentrato sulla crescita personale, la mindfulness o l'organizzazione. Usa un tono calmo e ispiratore.";
            } else {
                return; // Non generare suggerimenti per timer manuali senza categoria
            }

            const apiKey = "" 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const maxRetries = 5;
            let delay = 1000; // 1 secondo

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; 
                            continue;
                        }
                        throw new Error(`API call failed with status: ${response.status}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;

                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title); 
                        }
                        fetchedTip = { text, sources };
                        return;
                    }
                } catch (error) {
                    console.error("Gemini fetch error:", error);
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    }
                }
            }
        };


        // --- FUNZIONI TIMER CORE ---

        /** Formatta il tempo totale in HH:MM:SS */
        const formatTime = (totalSeconds) => {
            // Assicuriamo che il tempo non sia mai negativo
            if (totalSeconds < 0) totalSeconds = 0; 
            
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = totalSeconds % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };

        /** Aggiorna il display del timer e il cerchio di conteggio */
        const updateDisplay = () => {
            timerDisplay.textContent = formatTime(totalSecondsRemaining);
            
            // Logica del cerchio: calcola la percentuale di tempo *trascorso*
            if (totalSecondsInitial > 0) {
                const secondsPassed = totalSecondsInitial - totalSecondsRemaining;
                const percentagePassed = (secondsPassed / totalSecondsInitial); // 0 a 1
                
                // Rotazione: 270 gradi è il punto di partenza (ore 12)
                // 360 gradi è il giro completo
                // L'angolo va da 270 (inizio) a 630 (fine, 270 + 360)
                const rotation = 270 + (360 * percentagePassed);
                
                countdownFill.style.transform = `rotate(${rotation}deg)`;
            } else {
                // Tempo iniziale zero, cerchio pieno (rotazione 270)
                countdownFill.style.transform = `rotate(270deg)`;
            }
        };

        /** Avvia il timer (Resa asincrona per attendere la risposta di Gemini) */
        const startTimer = async () => {
            if (timerRunning) return;

            // Leggi gli input solo all'avvio, se non è una ripresa da pausa
            if (totalSecondsRemaining <= 0) {
                const h = parseInt(hoursInput.value) || 0;
                const m = parseInt(minutesInput.value) || 0;
                const s = parseInt(secondsInput.value) || 0;
                totalSecondsRemaining = h * 3600 + m * 60 + s;
                totalSecondsInitial = totalSecondsRemaining; 
            }

            if (totalSecondsRemaining <= 0) {
                showModal("Attenzione", "Imposta un tempo maggiore di zero.");
                return;
            }

            timerRunning = true;
            updateButtonState(true);
            updateDisplay();
            // Applica lo stile dinamico quando il timer inizia a correre
            applyDynamicStyles(lastPresetCategory); 

            countdownInterval = setInterval(async () => {
                totalSecondsRemaining--;
                updateDisplay();

                if (totalSecondsRemaining <= 0) {
                    clearInterval(countdownInterval);
                    timerRunning = false;
                    updateButtonState(false);
                    timerDisplay.textContent = "00:00:00";
                    countdownFill.style.transform = `rotate(630deg)`; // Completa il giro visivamente
                    timerDisplay.classList.remove('timer-running'); // Rimuove l'animazione di pulsazione
                    
                    // === CHIAMATA AL GONG ===
                    playGong(); 
                    
                    // Logica Gemini per i preset WorkOut / Focus Working
                    if (lastPresetCategory === 'WorkOut' || lastPresetCategory === 'Focus Working') {
                        let loadingMsg, categoryTitle;
                        if (lastPresetCategory === 'WorkOut') {
                            loadingMsg = "Caricamento del tuo **Consiglio WorkOut**...";
                            categoryTitle = "Consiglio WorkOut";
                        } else { // Focus Working
                            loadingMsg = "Caricamento del tuo **Consiglio Crescita Personale**...";
                            categoryTitle = "Consiglio Crescita Personale";
                        }
                        
                        // 1. Mostra la modale con un messaggio di caricamento
                        showModal("Timer Scaduto!", `Il tempo è finito. Ben fatto! ${loadingMsg}`);
                        
                        // 2. Recupera il consiglio (attende la risposta)
                        await fetchGeminiTip(lastPresetCategory); 
                        
                        // 3. Ri-mostra la modale con il consiglio completo
                        showModal("Timer Scaduto!", "Il tempo è finito. Ben fatto!");
                    } else {
                        // Per timer manuali senza categoria, mostra solo il messaggio di fine
                        showModal("Timer Scaduto!", "Il tempo è finito. Ben fatto!");
                    }
                    
                    // Resetta gli stili dinamici dopo la fine del timer
                    applyDynamicStyles(lastPresetCategory);
                }
            }, 1000);
        };

        /** Mette in pausa il timer */
        const pauseTimer = () => {
            if (!timerRunning) return;
            clearInterval(countdownInterval);
            timerRunning = false;
            updateButtonState(false);
            timerDisplay.classList.remove('timer-running'); // Rimuove l'animazione in pausa
        };

        /** Resetta il timer */
        const resetTimer = () => {
            pauseTimer();
            const h = parseInt(hoursInput.value) || 0;
            const m = parseInt(minutesInput.value) || 0;
            const s = parseInt(secondsInput.value) || 0;
            totalSecondsRemaining = h * 3600 + m * 60 + s;
            totalSecondsInitial = totalSecondsRemaining; // Aggiorna il valore iniziale
            updateDisplay();
            updateButtonState(false);
            timerDisplay.classList.remove('timer-running'); // Rimuove l'animazione
            
            // Applica lo stile dinamico per mantenere il colore del preset caricato
            applyDynamicStyles(lastPresetCategory); 
        };

        /** Gestisce lo stato dei pulsanti Start/Pausa e degli input */
        const updateButtonState = (isRunning) => {
            startButton.disabled = isRunning;
            pauseButton.disabled = !isRunning;
            hoursInput.disabled = isRunning;
            minutesInput.disabled = isRunning;
            secondsInput.disabled = isRunning;
        };
        
        // --- MODALE DI MESSAGGIO PERSONALIZZATO ---

        const showModal = (title, message) => {
            document.getElementById('modalTitle').textContent = title;
            
            let finalMessage = message;
            
            // Aggiunge il consiglio Gemini se è disponibile e il timer è scaduto
            if (fetchedTip.text && (lastPresetCategory === 'WorkOut' || lastPresetCategory === 'Focus Working') && title.includes("Timer Scaduto!")) {
                let tipTitle, tipColor;

                if (lastPresetCategory === 'WorkOut') {
                    tipTitle = "Consiglio WorkOut:";
                    tipColor = "text-green-300";
                } else { // Focus Working
                    tipTitle = "Consiglio Crescita Personale:";
                    tipColor = "text-cyan-300"; // Usa il colore del Focus Working
                }

                let tipHtml = `<p class="text-xl font-bold mt-4 mb-2 ${tipColor}">${tipTitle}</p>`;
                tipHtml += `<p class="text-lg text-gray-100 italic mb-4">${fetchedTip.text}</p>`;

                if (fetchedTip.sources.length > 0) {
                    tipHtml += `<p class="text-sm text-gray-500 mt-2">Fonti:</p><ul class="text-xs text-gray-500 list-disc list-inside space-y-1 text-left mx-auto max-w-xs">`;
                    fetchedTip.sources.slice(0, 2).forEach(source => {
                        tipHtml += `<li><a href="${source.uri}" target="_blank" class="hover:text-cyan-400 truncate" title="${source.title}">${source.title}</a></li>`;
                    });
                    tipHtml += `</ul>`;
                }
                
                finalMessage += tipHtml;
                fetchedTip = { text: null, sources: [] }; // Pulisce il tip dopo la visualizzazione
            }
            
            document.getElementById('modalMessage').innerHTML = finalMessage;
            messageModal.classList.remove('hidden');
        };

        const hideModal = () => {
            messageModal.classList.add('hidden');
        };

        // --- EVENT LISTENERS ---

        // Controlli Timer
        startButton.addEventListener('click', startTimer);
        pauseButton.addEventListener('click', pauseTimer);
        resetButton.addEventListener('click', resetTimer);

        // Input Time (Reset automatico quando si cambia il tempo)
        [hoursInput, minutesInput, secondsInput].forEach(input => {
            input.addEventListener('change', resetTimer);
            input.addEventListener('input', (e) => {
                // Limita i valori
                let val = parseInt(e.target.value) || 0;
                let max = parseInt(e.target.max);
                let min = parseInt(e.target.min);

                if (val > max) e.target.value = max;
                if (val < min) e.target.value = min;
                
                // Per l'impostazione manuale, usiamo la categoria di default
                lastPresetCategory = 'Focus Working'; 
                fetchedTip = { text: null, sources: [] }; // Pulisce il tip
                
                resetTimer(); // Forza il reset del timer con i nuovi valori
            });
        });

        // Gestione Preset (Load dei timer statici) - Uniamo gli ascoltatori per entrambe le liste
        [focusPresetsList, workoutPresetsList].forEach(list => {
            list.addEventListener('click', (e) => {
                const button = e.target.closest('.preset-button');
                if (!button) return;

                // Estrae i dati dai data-attributi del pulsante
                const name = button.dataset.name;
                const category = button.dataset.category;
                const h = parseInt(button.dataset.h) || 0;
                const m = parseInt(button.dataset.m) || 0;
                const s = parseInt(button.dataset.s) || 0;

                loadPreset({ name: name, hours: h, minutes: m, seconds: s }, category);
            });
        });

        // Chiusura Modale
        closeModalButton.addEventListener('click', hideModal);

        // Chiamata iniziale per aggiornare il display e applicare lo stile di default
        loadPreset({ name: "Default", hours: 0, minutes: 20, seconds: 0 }, 'Focus Working');
    </script>
</body>
</html>
